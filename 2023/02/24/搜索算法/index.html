<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>搜索算法 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="搜索算法本篇的重点是理解狄杰斯特拉算法！！ BFS 泛洪 无权  Dijkstrad 模版及应用Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。 「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。我们用邻接表的场景更多，**如果你想把一个问题抽象成「图」的问">
<meta property="og:type" content="article">
<meta property="og:title" content="搜索算法">
<meta property="og:url" content="http://example.com/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="搜索算法本篇的重点是理解狄杰斯特拉算法！！ BFS 泛洪 无权  Dijkstrad 模版及应用Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。 「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。我们用邻接表的场景更多，**如果你想把一个问题抽象成「图」的问">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-02-24T21:29:52.000Z">
<meta property="article:modified_time" content="2023-02-24T21:33:33.489Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-24 15:33:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">搜索算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-24T21:29:52.000Z" title="Created 2023-02-24 15:29:52">2023-02-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-24T21:33:33.489Z" title="Updated 2023-02-24 15:33:33">2023-02-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="搜索算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><p><strong>本篇的重点是理解狄杰斯特拉算法！！</strong></p>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><ol>
<li>泛洪</li>
<li>无权</li>
</ol>
<h4 id="Dijkstrad-模版及应用"><a href="#Dijkstrad-模版及应用" class="headerlink" title="Dijkstrad 模版及应用"></a>Dijkstrad 模版及应用</h4><p><strong>Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。</strong></p>
<p>「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。我们用邻接表的场景更多，**如果你想把一个问题抽象成「图」的问题，那么首先要实现一个 API <code>adj</code>**，类似多叉树节点中的 <code>children</code> 字段记录当前节点的所有子节点，<code>adj(s)</code> 就是计算一个节点 <code>s</code> 的相邻节点</p>
<p>比如上面说的用邻接表表示「图」的方式，<code>adj</code> 函数就可以这样表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"><span class="comment">// 输入节点 s，返回 s 的相邻节点</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> graph[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于「加权图」，我们需要知道两个节点之间的边权重是多少，所以还可以抽象出一个 <code>weight</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回节点 from 到节点 to 之间的边的权重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>;</span><br></pre></td></tr></table></figure>

<p>这个 <code>weight</code> 方法可以根据实际情况而定，因为不同的算法题，题目给的「权重」含义可能不一样，我们存储权重的方式也不一样。</p>
<p>有了上述基础知识，就可以搞定 Dijkstra 算法了，下面我给你从二叉树的层序遍历开始推演出 Dijkstra 算法的实现。</p>
<p>我们之前说过<strong>二叉树的层级遍历框架</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来思考一个问题，注意二叉树的层级遍历 <code>while</code> 循环里面还套了个 <code>for</code> 循环，为什么要这样？</p>
<p><code>while</code> 循环和 <code>for</code> 循环的配合正是这个遍历框架设计的巧妙之处：</p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153054036.png" alt="image-20230224153054036"></p>
<p><strong><code>while</code> 循环控制一层一层往下走，<code>for</code> 循环利用 <code>sz</code> 变量控制从左到右遍历每一层二叉树节点</strong>。</p>
<p>注意我们代码框架中的 <code>depth</code> 变量，其实就记录了当前遍历到的层数。换句话说，每当我们遍历到一个节点 <code>cur</code>，都知道这个节点属于第几层。</p>
<p>算法题经常会问二叉树的最大深度呀，最小深度呀，层序遍历结果呀，等等问题，所以记录下来这个深度 <code>depth</code> 是有必要的。</p>
<p>基于二叉树的遍历框架，我们又可以扩展出多叉树的层序遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵多叉树的根节点，层序遍历这棵多叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历多叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode child : cur.children) &#123;</span><br><span class="line">                q.offer(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于多叉树的遍历框架，我们又可以扩展出 BFS（广度优先搜索）的算法框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入起点，进行 BFS 搜索</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录搜索的步数</span></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散一步 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;从 %s 到 %s 的最短距离是 %s&quot;</span>, start, cur, step);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓 BFS 算法，就是把算法问题抽象成一幅「无权图」，然后继续玩二叉树层级遍历那一套罢了。</p>
<p>所谓「无权图」，与其说每条「边」没有权重，不如说每条「边」的权重都是 1，从起点 <code>start</code> 到任意一个节点之间的路径权重就是它们之间「边」的条数，那可不就是 <code>step</code> 变量记录的值么？</p>
<p>再加上 BFS 算法利用 <code>for</code> 循环一层一层向外扩散的逻辑和 <code>visited</code> 集合防止走回头路的逻辑，<strong>当你每次从队列中拿出节点 <code>cur</code> 的时候，从 <code>start</code> 到 <code>cur</code> 的最短权重就是 <code>step</code> 记录的步数。</strong></p>
<p>但是，到了「加权图」的场景，事情就没有这么简单了，因为你不能默认每条边的「权重」都是 1 了，这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边），比如下图的例子：</p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153118365.png" alt="image-20230224153118365"></p>
<p>如果沿用 BFS 算法中的 <code>step</code> 变量记录「步数」，显然红色路径一步就可以走到终点，但是这一步的权重很大；正确的最小权重路径应该是绿色的路径，虽然需要走很多步，但是路径权重依然很小。</p>
<p>其实 Dijkstra 和 BFS 算法差不多，不过在讲解 Dijkstra 算法框架之前，我们首先需要对之前的框架进行如下改造：</p>
<p><strong>想办法去掉 <code>while</code> 循环里面的 <code>for</code> 循环</strong>。</p>
<p>为什么？有了刚才的铺垫，这个不难理解，刚才说 <code>for</code> 循环是干什么用的来着？</p>
<p>是为了让二叉树一层一层往下遍历，让 BFS 算法一步一步向外扩散，因为这个层数 <code>depth</code>，或者这个步数 <code>step</code>，在之前的场景中有用。</p>
<p>但现在我们想解决「加权图」中的最短路径问题，「步数」已经没有参考意义了，「路径的权重之和」才有意义，所以这个 <code>for</code> 循环可以被去掉。</p>
<p>怎么去掉？就拿二叉树的层级遍历来说，其实你可以直接去掉 <code>for</code> 循环相关的代码：</p>
<p>&#x2F;&#x2F;我最开始学二叉树层级遍历的时候，就没用For循环，还在想为什么要多加一个没用的for循环（因为for循环是来记录层数的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树的每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        printf(<span class="string">&quot;我不知道节点 %s 在第几层&quot;</span>, cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但问题是，没有 <code>for</code> 循环，你也没办法维护 <code>depth</code> 变量了。</p>
<p>如果你想同时维护 <code>depth</code> 变量，让每个节点 <code>cur</code> 知道自己在第几层，可以想其他办法，比如新建一个 <code>State</code> 类，记录每个节点所在的层数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 记录 node 节点的深度</span></span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    TreeNode node;</span><br><span class="line"></span><br><span class="line">    State(TreeNode node, <span class="type">int</span> depth) &#123;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;State&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树的每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur_node</span> <span class="operator">=</span> cur.node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur_depth</span> <span class="operator">=</span> cur.depth;</span><br><span class="line">        printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur_node, cur_depth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur_node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(cur_node.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(cur_node.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以不使用 <code>for</code> 循环也确切地知道每个二叉树节点的深度了。</p>
<p><strong>如果你能够理解上面这段代码，我们就可以来看 Dijkstra 算法的代码框架了</strong>。</p>
<p><strong>Dijkstra 算法框架</strong></p>
<p><strong>首先，我们先看一下 Dijkstra 算法的签名</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;Integer&gt;[] graph);</span><br></pre></td></tr></table></figure>

<p>输入是一幅图 <code>graph</code> 和一个起点 <code>start</code>，返回是一个记录最短路径权重的数组。</p>
<p>比方说，输入起点 <code>start = 3</code>，函数返回一个 <code>int[]</code> 数组，假设赋值给 <code>distTo</code> 变量，那么从起点 <code>3</code> 到节点 <code>6</code> 的最短路径权重的值就是 <code>distTo[6]</code>。</p>
<p>是的，标准的 Dijkstra 算法会把从起点 <code>start</code> 到所有其他节点的最短路径都算出来。</p>
<p>当然，如果你的需求只是计算从起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。</p>
<p><strong>其次，我们也需要一个 <code>State</code> 类来辅助算法的运行</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点的 id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 从 start 节点到当前节点的距离</span></span><br><span class="line">    <span class="type">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    State(<span class="type">int</span> id, <span class="type">int</span> distFromStart) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似刚才二叉树的层序遍历，我们也需要用 <code>State</code> 类记录一些额外信息，也就是使用 <code>distFromStart</code> 变量记录从起点 <code>start</code> 到当前这个节点的距离。</p>
<p>刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 <code>visited</code> 数组防止走回头路，每个节点只会经过一次。</p>
<p>加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 <code>distFromStart</code> 可能都不一样，比如下图：</p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153136253.png" alt="image-20230224153136253"></p>
<p>我会经过节点 <code>5</code> 三次，每次的 <code>distFromStart</code> 值都不一样，那我取 <code>distFromStart</code> 最小的那次，不就是从起点 <code>start</code> 到节点 <code>5</code> 的最短路径权重了么？</p>
<p>好了，明白上面的几点，我们可以来看看 Dijkstra 算法的代码模板。</p>
<p><strong>其实，Dijkstra 可以理解成一个带 dp table（或者说备忘录）的 BFS 算法，伪码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回节点 from 到节点 to 之间的边的权重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入节点 s 返回 s 的相邻节点</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;Integer&gt;[] graph) &#123;</span><br><span class="line">    <span class="comment">// 图中节点的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="comment">// 记录最短路径的权重，你可以理解为 dp table</span></span><br><span class="line">    <span class="comment">// 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span></span><br><span class="line">    <span class="type">int</span>[] distTo = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">    <span class="comment">// 求最小值，所以 dp table 初始化为正无穷</span></span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// base case，start 到 start 的最短距离就是 0</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，distFromStart 较小的排在前面</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点 start 开始进行 BFS</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="comment">// 已经有一条更短的路径到达 curNode 节点了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 curNode 的相邻节点装入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nextNodeID : adj(curNodeID)) &#123;</span><br><span class="line">            <span class="comment">// 看看从 curNode 达到 nextNode 的距离是否会更短</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">distToNextNode</span> <span class="operator">=</span> distTo[curNodeID] + weight(curNodeID, nextNodeID);</span><br><span class="line">            <span class="keyword">if</span> (distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp table</span></span><br><span class="line">                distTo[nextNodeID] = distToNextNode;</span><br><span class="line">                <span class="comment">// 将这个节点以及距离放入队列</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比普通的 BFS 算法，你可能会有以下疑问</strong>：</p>
<p><strong>1、没有 <code>visited</code> 集合记录已访问的节点，所以一个节点会被访问多次，会被多次加入队列，那会不会导致队列永远不为空，造成死循环</strong>？</p>
<p><strong>2、为什么用优先级队列 <code>PriorityQueue</code> 而不是 <code>LinkedList</code> 实现的普通队列？为什么要按照 <code>distFromStart</code> 的值来排序</strong>？</p>
<p><strong>3、如果我只想计算起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，是否可以修改算法，提升一些效率</strong>？</p>
<p>我们先回答第一个问题，为什么这个算法不用 <code>visited</code> 集合也不会死循环。</p>
<p>对于这类问题，我教你一个思考方法：</p>
<p>循环结束的条件是队列为空，那么你就要注意看什么时候往队列里放元素（调用 <code>offer</code>）方法，再注意看什么时候从队列往外拿元素（调用 <code>poll</code> 方法）。</p>
<p><code>while</code> 循环每执行一次，都会往外拿一个元素，但想往队列里放元素，可就有很多限制了，必须满足下面这个条件：</p>
<p>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看看从 curNode 达到 nextNode 的距离是否会更短</span></span><br><span class="line"><span class="keyword">if</span> (distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">    <span class="comment">// 更新 dp table</span></span><br><span class="line">    distTo[nextNodeID] = distToNextNode;</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即：只有curDistance&lt;dp table的时候，才会压栈，压完栈就会更新dp table，同时，在优先级队列里面排在了最前面，之前压栈的相同节点都会排在后面，并且在后续弹出之后会直接continue跳过。</strong></p>
<p>这也是为什么我说 <code>distTo</code> 数组可以理解成我们熟悉的 dp table，因为这个算法逻辑就是在不断的最小化 <code>distTo</code> 数组中的元素：</p>
<p>如果你能让到达 <code>nextNodeID</code> 的距离更短，那就更新 <code>distTo[nextNodeID]</code> 的值，让你入队，否则的话对不起，不让入队。</p>
<p><strong>因为两个节点之间的最短距离（路径权重）肯定是一个确定的值，不可能无限减小下去，所以队列一定会空，队列空了之后，<code>distTo</code> 数组中记录的就是从 <code>start</code> 到其他节点的最短距离</strong>。</p>
<p>接下来解答第二个问题，为什么要用 <code>PriorityQueue</code> 而不是 <code>LinkedList</code> 实现的普通队列？</p>
<p>如果你非要用普通队列，其实也没问题的，你可以直接把 <code>PriorityQueue</code> 改成 <code>LinkedList</code>，也能得到正确答案，但是效率会低很多。</p>
<p><strong>Dijkstra 算法使用优先级队列，主要是为了效率上的优化，类似一种贪心算法的思路</strong>。</p>
<p>为什么说是一种贪心思路呢，比如说下面这种情况，你想计算从起点 <code>start</code> 到终点 <code>end</code> 的最短路径权重：</p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153155600.png" alt="image-20230224153155600"></p>
<p>假设你当前只遍历了图中的这几个节点，那么你下一步准备遍历那个节点？这三条路径都可能成为最短路径的一部分，<strong>但你觉得哪条路径更有「潜力」成为最短路径中的一部分</strong>？</p>
<p>从目前的情况来看，显然橙色路径的可能性更大嘛，所以我们希望节点 <code>2</code> 排在队列靠前的位置，优先被拿出来向后遍历。</p>
<p>所以我们使用 <code>PriorityQueue</code> 作为队列，让 <code>distFromStart</code> 的值较小的节点排在前面，这就类似我们之前讲 <a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/ru-he-yun--48a7c/">贪心算法</a> 说到的贪心思路，可以很大程度上优化算法的效率。</p>
<p>大家应该听过 Bellman-Ford 算法，这个算法是一种更通用的最短路径算法，因为它可以处理带有负权重边的图，Bellman-Ford 算法逻辑和 Dijkstra 算法非常类似，用到的就是普通队列，本文就提一句，后面有空再具体写。</p>
<p>接下来说第三个问题，如果只关心起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，是否可以修改代码提升算法效率。</p>
<p>肯定可以的，因为我们标准 Dijkstra 算法会算出 <code>start</code> 到所有其他节点的最短路径，你只想计算到 <code>end</code> 的最短路径，相当于减少计算量，当然可以提升效率。</p>
<p>需要在代码中做的修改也非常少，只要改改函数签名，再加个 if 判断就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入起点 start 和终点 end，计算起点到终点的最短距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;Integer&gt;[] graph)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里加一个判断就行了，其他代码不用改</span></span><br><span class="line">        <span class="keyword">if</span> (curNodeID == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> curDistFromStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果运行到这里，说明从 start 无法走到 end</span></span><br><span class="line">    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因为优先级队列自动排序的性质，每次从队列里面拿出来的都是 <code>distFromStart</code> 值最小的，所以当你第一次从队列中拿出终点 <code>end</code> 时，此时的 <code>distFromStart</code> 对应的值就是从 <code>start</code> 到 <code>end</code> 的最短距离。</strong></p>
<p>这个算法较之前的实现提前 return 了，所以效率有一定的提高。</p>
<p>狄杰斯特拉和BFS的对比就在于，狄杰斯特拉不再以Depth作为每个节点到start的距离了，而是每次到达每个节点都会维护一个state的变量，这个变量记录了本次到达此节点所经过的路径总和。当然，为了剪枝，当你这个路径总和大于dp table里面的值的时候，没必要维护。但从原理上来讲，就是每次到达都要计算一次本次到达的路径总和的。</p>
<h5 id="狄杰斯特拉过程："><a href="#狄杰斯特拉过程：" class="headerlink" title="狄杰斯特拉过程："></a>狄杰斯特拉过程：</h5><p>弹出并检查本节点 （是否curState &gt; dp table)</p>
<p><code>如果大于的话，就没必要压栈相邻节点了，因为一定有更短到达本节点的路径让相邻节点路径也变短</code></p>
<p>检查子节点并压栈 （是否通过本节点到达子节点要小于dp table）</p>
<p><code>如果通过本节点到达子节点要小于dp table的话，就更新dp table的值并压栈</code></p>
<p>注意：</p>
<ol>
<li>狄杰斯特拉是维护一个全局数组，这个数组一直更新并记录<strong>每个节点</strong>到start的最短距离</li>
<li>每次压栈压的不是节点，是次，是每次到达节点之后发现最短距离可以更新，就压栈。但对于同一个节点来说如果后面出现了压栈，那么前面的压栈就废了，弹出时不会再检查子节点会直接跳过。（利用的是优先级队列）</li>
<li>BFS的最短路径搜索，只能找无权图，有权图就得狄杰斯特拉</li>
<li>注意，我们这个state是维护了节点的id和到start的距离，也就是说我们最后得到的之后每个节点到start的最短距离，并不知道这个最短路径是什么。如果我们想知道这条路径是什么，就要在state里面维护一个变量：上一个节点是什么。</li>
</ol>
<h4 id="贪心搜索"><a href="#贪心搜索" class="headerlink" title="贪心搜索"></a>贪心搜索</h4><p>使用广度优先搜索和 Dijkstra 算法，边界向各个方向扩展。如果您试图找到通往所有位置或许多位置的路径，这是一个合理的选择。然而，一种常见的情况是只找到一条到一个位置的路径。让我们让边界向目标方向的扩展比向其他方向的扩展更多。首先，我们将定义一个<em>启发式</em>函数，告诉我们离目标有多近：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heuristic</span>(<span class="params">a, b</span>):</span><br><span class="line">   <span class="comment"># Manhattan distance on a square grid</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y)</span><br></pre></td></tr></table></figure>

<p>在 Dijkstra 算法中，我们使用距起点的实际距离<em>来</em>进行优先级队列排序。相反，在<strong>Greedy Best First Search中，我们将使用到</strong><em>目标的</em>估计距离来进行优先级队列排序。最接近目标的位置将首先被探索。该代码使用 Dijkstra 算法中的优先级队列，但没有<code>cost_so_far</code></p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153211950.png" alt="image-20230224153211950"></p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153231736.png" alt="image-20230224153231736"></p>
<h4 id="A-搜索算法"><a href="#A-搜索算法" class="headerlink" title="A*搜索算法"></a>A*搜索算法</h4><p>Dijkstra 算法可以很好地找到最短路径，但它会浪费时间探索没有希望的方向。Greedy Best First Search 在有希望的方向上探索，但它可能找不到最短路径。A* 算法<em>同时</em>使用距起点的实际距离和距目标的估计距离。</p>
<p>The code is very similar to Dijkstra’s Algorithm:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">frontier = PriorityQueue()</span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()</span><br><span class="line">cost_so_far = <span class="built_in">dict</span>()</span><br><span class="line">came_from[start] = <span class="literal">None</span></span><br><span class="line">cost_so_far[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> current == goal:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      new_cost = cost_so_far[current] + graph.cost(current, <span class="built_in">next</span>)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far[<span class="built_in">next</span>]:</span><br><span class="line">         cost_so_far[<span class="built_in">next</span>] = new_cost</span><br><span class="line">         priority = new_cost + heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br></pre></td></tr></table></figure>

<p><strong>比较</strong>算法：Dijkstra 算法计算距起点的距离。贪心最佳优先搜索估计到目标点的距离。A* 正在使用这两个距离的总和。</p>
<p><img src="/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/image-20230224153246886.png" alt="image-20230224153246886"></p>
<p>A* 是两全其美的。只要启发式算法不高估距离，A* 就会找到最佳路径，就像 Dijkstra 算法所做的那样。A* 使用启发式算法对节点重新排序，以便更有<em>可能</em>更快地遇到目标节点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/">http://example.com/2023/02/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/24/B-Plus-Tree/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">B-Plus-Tree</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/23/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">栈与队列</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">搜索算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstrad-%E6%A8%A1%E7%89%88%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">Dijkstrad 模版及应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%84%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.0.0.2.1.</span> <span class="toc-text">狄杰斯特拉过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E6%90%9C%E7%B4%A2"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">贪心搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">A*搜索算法</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划"/></a><div class="content"><a class="title" href="/2023/03/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2023-03-19T17:30:53.000Z" title="Created 2023-03-19 12:30:53">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="贪心算法详解"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪心算法详解"/></a><div class="content"><a class="title" href="/2023/03/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="贪心算法详解">贪心算法详解</a><time datetime="2023-03-16T18:27:26.000Z" title="Created 2023-03-16 13:27:26">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="回溯算法详解"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="回溯算法详解"/></a><div class="content"><a class="title" href="/2023/03/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="回溯算法详解">回溯算法详解</a><time datetime="2023-03-13T16:48:55.000Z" title="Created 2023-03-13 11:48:55">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2023/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2023-03-05T18:33:43.000Z" title="Created 2023-03-05 12:33:43">2023-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/28/%E6%89%98%E7%A6%8F%E5%86%99%E4%BD%9C/" title="托福写作"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="托福写作"/></a><div class="content"><a class="title" href="/2023/02/28/%E6%89%98%E7%A6%8F%E5%86%99%E4%BD%9C/" title="托福写作">托福写作</a><time datetime="2023-02-28T18:07:48.000Z" title="Created 2023-02-28 12:07:48">2023-02-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>